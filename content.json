{"meta":{"title":"FlrPG","subtitle":"","description":"","author":"FlrPG","url":"https://flrpg.github.io","root":"/"},"pages":[{"title":"404","date":"2020-10-10T10:16:38.000Z","updated":"2020-10-10T10:16:38.028Z","comments":true,"path":"404/index.html","permalink":"https://flrpg.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-10T10:16:21.000Z","updated":"2020-10-10T10:16:21.734Z","comments":true,"path":"about/index.html","permalink":"https://flrpg.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-10T10:15:59.000Z","updated":"2020-10-10T10:16:00.017Z","comments":true,"path":"tags/index.html","permalink":"https://flrpg.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-10T10:16:30.000Z","updated":"2020-10-10T10:16:30.461Z","comments":true,"path":"categories/index.html","permalink":"https://flrpg.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot + JPA + 多数据源 + JDNI配置","slug":"issue/issue-002-多数据源","date":"2021-03-16T01:48:17.000Z","updated":"2021-03-16T02:29:32.533Z","comments":true,"path":"2021/03/16/issue/issue-002-多数据源/","link":"","permalink":"https://flrpg.github.io/2021/03/16/issue/issue-002-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","excerpt":"","text":"配置说明： 在SpringBoot 下多数据源配置、使用 （一方引用JDNI 配置） application.yml 文件配置： 主数据源DB2 配置信息读取 Tomcat JDNI 配置 spring: datasource: primary: jndi-name: java:comp/env/jdbc/XXX expected-type: javax.sql.DataSource driver-class-name: com.ibm.db2.jcc.DB2Driver jdbc-url: jdbc:db2://127.0.0.1:60000/test username: root password: root second: driver-class-name: com.mysql.jdbc.Driver jdbc-url: jdbc:mysql://127.0.0.1:3306/test username: root password: root jpa: database-platform: org.hibernate.dialect.DB2Dialect show-sql: false hibernate: ddl-auto: none properties: hibernate: primary-dialect: org.hibernate.dialect.DB2Dialect second-dialect: org.hibernate.dialect.MySQL55Dialect DataSourceConfig.java 配置类： @Configuration public class DataSourceConfig &#123; @Value(&quot;$&#123;spring.datasource.primary.jndi-name&#125;&quot;) private String jndiName; /** * 第一个数据连接，默认优先级最高 * * @return */ @Primary @Bean(name = &quot;primaryDataSource&quot;) @Qualifier(&quot;primaryDataSource&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;) public DataSource PrimaryDataSource() throws NamingException &#123; if (!StrUtil.isNotEmpty(jndiName)) &#123; return DataSourceBuilder.create().build(); &#125; else &#123; //存在jdni 配置时先加载 tomcat 配置 导入方式一： Context initCt = new InitialContext(); return (DataSource) initCt.lookup(jndiName); /* //导入方式二： JndiObjectFactoryBean bean = new JndiObjectFactoryBean(); bean.setJndiName(jndiName); bean.setProxyInterface(DataSource.class); bean.setLookupOnStartup(false); bean.afterPropertiesSet(); return (DataSource)bean.getObject();*/ &#125; /** * 第二个数据源 * * @return */ @Bean(name = &quot;secondDataSource&quot;) @Qualifier(&quot;secondDataSource&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.second&quot;) public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().build(); &#125; PrimaryConfig.java 主数据源配置： @Configuration @EnableTransactionManagement @EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactoryPrimary&quot;, transactionManagerRef = &quot;transactionManagerPrimary&quot;, basePackages = &#123;&quot;com.cathay.east.repo&quot;&#125;) //设置Repository所在位置 public class PrimaryConfig &#123; @Autowired private HibernateProperties hibernateProperties; @Autowired @Qualifier(&quot;primaryDataSource&quot;) private DataSource primaryDataSource; @Autowired private JpaProperties jpaProperties; @Autowired private Environment env; @Primary @Bean(name = &quot;entityManagerPrimary&quot;) public EntityManager entityManager(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; return entityManagerFactoryPrimary(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = &quot;entityManagerFactoryPrimary&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; Map&lt;String, Object&gt; properties = hibernateProperties.determineHibernateProperties( jpaProperties.getProperties(), new HibernateSettings()); //Jpa 方言配置 properties.put(&quot;hibernate.dialect&quot;, env.getProperty(&quot;spring.jpa.properties.hibernate.primary-dialect&quot;)); return builder .dataSource(primaryDataSource) .properties(properties) //设置实体类所在位置 .packages(&quot;com.cathay.east.entity&quot;,&quot;com.cathay.east.origin&quot;,&quot;com.cathay.east.daily&quot;) //多数据源EntityManager 引用导入 .persistenceUnit(&quot;primaryPersistenceUnit&quot;) .build(); &#125; @Primary @Bean(name = &quot;transactionManagerPrimary&quot;) public PlatformTransactionManager transactionManagerPrimary(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject()); &#125; &#125; SecondConfig.java 第二数据源配置： @Configuration @EnableTransactionManagement @EnableJpaRepositories( entityManagerFactoryRef = &quot;entityManagerFactorySecond&quot;, transactionManagerRef = &quot;transactionManagerSecond&quot;, basePackages = &#123;&quot;com.cathay.east.mysqlRepo&quot;&#125;) //设置Repository所在位置 public class SecondConfig &#123; @Autowired @Qualifier(&quot;secondDataSource&quot;) private DataSource SecondDataSource; @Autowired private JpaProperties jpaProperties; @Autowired private HibernateProperties hibernateProperties; @Autowired private Environment env; @Bean(name = &quot;entityManagerSecond&quot;) public EntityManager entityManager(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; return entityManagerFactorySecond(builder).getObject().createEntityManager(); &#125; @Bean(name = &quot;entityManagerFactorySecond&quot;) public LocalContainerEntityManagerFactoryBean entityManagerFactorySecond(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; Map&lt;String, Object&gt; properties = hibernateProperties.determineHibernateProperties( jpaProperties.getProperties(), new HibernateSettings()); properties.put(&quot;hibernate.dialect&quot;, env.getProperty(&quot;spring.jpa.properties.hibernate.second-dialect&quot;)); return builder .dataSource(SecondDataSource) .properties(properties) //设置实体类所在位置 .packages(&quot;com.cathay.east.mysqlEntity&quot;) .persistenceUnit(&quot;SecondPersistenceUnit&quot;) .build(); &#125; @Bean(name = &quot;transactionManagerSecond&quot;) PlatformTransactionManager transactionManagerSecond(org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactorySecond(builder).getObject()); &#125; 测试代码： @Autowired private PolGroupRepository polGroupRepository; @Autowired private WtTtbdbOTempLogRepository wtTtbdbOTempLogRepository; @Test public void dataSource() &#123; //主数据源 Page&lt;PolGroup&gt; polGroups = polGroupRepository.findAll( PageRequest.of(0, Constant.PAGE_SIZE)); System.out.println(polGroups.stream().count()); //第二数据源 Page&lt;WtTtbdbOTempLogEntity&gt; page = wtTtbdbOTempLogRepository.findAll(PageRequest.of(0, Constant.PAGE_SIZE)); System.out.println(page.stream().count()); &#125; 注意事项： 注入EntityManager时 – 注意配置的数据源 unitName @PersistenceContext(unitName=&quot;primaryPersistenceUnit&quot;) private EntityManager entityManager; 生成的实体类 与 Repository类 需要按对应数据源指定文件夹位置 //设置Repository所在位置 basePackages = &#123;&quot;com.cathay.east.repo&quot;&#125; //设置实体类所在位置 .packages(&quot;com.cathay.east.entity&quot;,&quot;com.cathay.east.origin&quot;,&quot;com.cathay.east.daily&quot;)","categories":[{"name":"问题集","slug":"问题集","permalink":"https://flrpg.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"}],"tags":[{"name":"issue","slug":"issue","permalink":"https://flrpg.github.io/tags/issue/"}]},{"title":"【项目总结】GTRS-EAST","slug":"summary/summary-001","date":"2021-03-12T02:34:38.000Z","updated":"2021-03-12T02:47:04.954Z","comments":true,"path":"2021/03/12/summary/summary-001/","link":"","permalink":"https://flrpg.github.io/2021/03/12/summary/summary-001/","excerpt":"","text":"项目说明 业务数据抽取上报报送EAST，涉及原表数据的抽取、转码、脱敏、核验、上报。 项目流程图 业务流程图 项目内碰到的问题点 各业务表统一 LSH 生成（唯一ID） 大数据量业务字段抽取 接口设计规范问题 查询sql优化-DB2 多数据源 + JDNI配置","categories":[{"name":"总结","slug":"总结","permalink":"https://flrpg.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"db-db2-001","slug":"db/db-db2-001","date":"2021-02-04T05:19:49.000Z","updated":"2021-02-04T05:19:49.266Z","comments":true,"path":"2021/02/04/db/db-db2-001/","link":"","permalink":"https://flrpg.github.io/2021/02/04/db/db-db2-001/","excerpt":"","text":"","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://flrpg.github.io/tags/tag1/"}]},{"title":"OS-mac-001","slug":"os/OS-mac-001","date":"2021-01-27T07:11:31.000Z","updated":"2021-01-28T09:31:28.310Z","comments":true,"path":"2021/01/27/os/OS-mac-001/","link":"","permalink":"https://flrpg.github.io/2021/01/27/os/OS-mac-001/","excerpt":"","text":"机械革命 1.begin macOS 镜像 balenaEtcher 工具箱配置文件 DiskGenius分区助手 Windows内 文件 md5值 检验 certutil -hashfile “macOS Big Sur 11.1 20C69 Installer for CLOVER 5127 and WEPE.dmg” MD5","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"os","slug":"os","permalink":"https://flrpg.github.io/tags/os/"}]},{"title":"Jpa","slug":"db/db-jpa-001","date":"2021-01-19T01:50:04.000Z","updated":"2021-01-19T07:02:12.392Z","comments":true,"path":"2021/01/19/db/db-jpa-001/","link":"","permalink":"https://flrpg.github.io/2021/01/19/db/db-jpa-001/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://flrpg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Jpa","slug":"Jpa","permalink":"https://flrpg.github.io/tags/Jpa/"}]},{"title":"plan-2021","slug":"plan/plan-2021","date":"2021-01-15T01:53:52.000Z","updated":"2021-03-12T09:34:35.754Z","comments":true,"path":"2021/01/15/plan/plan-2021/","link":"","permalink":"https://flrpg.github.io/2021/01/15/plan/plan-2021/","excerpt":"","text":"2021 DP JUC JVM Redis Mysql Netty — Source-Spring Source-Netty — Project alg graph TD A[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] graph LR A[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] graph TD A[方形] --> B(圆角) B --> C{条件a} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F[竖向流程图] graph LR A[方形] -->B(圆角) B --> C{条件a} C -->|a=1| D[结果1] C -->|a=2| E[结果2] F[横向流程图]","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"plan","slug":"plan","permalink":"https://flrpg.github.io/tags/plan/"}]},{"title":"Redis说明","slug":"db/db-redis-002","date":"2021-01-13T02:54:24.000Z","updated":"2021-01-15T01:52:29.006Z","comments":true,"path":"2021/01/13/db/db-redis-002/","link":"","permalink":"https://flrpg.github.io/2021/01/13/db/db-redis-002/","excerpt":"","text":"数据类型 （DEL KEYNAME） 类型 特性 实例 String 二进制安全，最大存储512M，String的key为任意类型（图片|序列化对象） 127.0.0.1:0&gt;set STRK aa“OK”127.0.0.1:0&gt;get STRK“aa” Hash 键值对集合，适合存储对象 127.0.0.1:0&gt;hmset MAPK name “ZS”“OK”127.0.0.1:0&gt;hmget MAPK name 1) “ZS” List 双向链表，提供了在头尾操作的api 127.0.0.1:0&gt;lpush LISTK aa“1”127.0.0.1:0&gt;lpush LISTK bb“2”127.0.0.1:0&gt;lrange LISTK 0 10 1) “bb” 2) “aa”应用场景：消息队列 Set 无序集合 127.0.0.1:0&gt;sadd SETK aa“1”127.0.0.1:0&gt;sadd SETK bb“1”127.0.0.1:0&gt;sadd SETK aa“0”127.0.0.1:0&gt;smembers SETK 1) “aa” 2) “bb” zset 加权重无序集合zrange 取索引区间值zrevrange 去权重区间值 127.0.0.1:0&gt;zadd SETK 0 aa 1 aa 0 bb“2”127.0.0.1:0&gt;zrange ZSETK 0 10 1) “bb” 2) “aa”127.0.0.1:0&gt;zrevrange ZSETK 0 0 1) “aa” Redis 命令 redis-cli -h host -p port -a password Redis 发布订阅 SUBSCRIBE channel channel 订阅给定的一个或多个频道的信息PUBLISH channel message 将信息发送到指定的频道。 redis-cli 创建两个客户端链接（cli1，cli2） cli1&gt;subscribe channelTest (cli1订阅channelTest频道信息) cli2&gt;publish channelTest hello （cli2向channelTest频道发布 “hello” 消息） cli1 接收消息效果 “message” “channelTest” “hello” Redis事务 MULT 标记一个事务块的开始 EXEC 执行所有事务块内的命令 127.0.0.1:6379&gt; multi OK 127.0.0.1:6379&gt; set STRK multi QUEUED 127.0.0.1:6379&gt; get STRK QUEUED 127.0.0.1:6379&gt; exec 1) OK 2) &quot;multi&quot; Java中使用 Jedis","categories":[{"name":"数据库","slug":"数据库","permalink":"https://flrpg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://flrpg.github.io/tags/redis/"}]},{"title":"Redis-分布式锁应用（基于 redisson）","slug":"db/db-redis-001","date":"2021-01-08T10:25:23.000Z","updated":"2021-01-13T03:00:15.797Z","comments":true,"path":"2021/01/08/db/db-redis-001/","link":"","permalink":"https://flrpg.github.io/2021/01/08/db/db-redis-001/","excerpt":"","text":"Maven依赖（github地址 https://github.com/redisson/redisson/）： &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.14.1&lt;/version&gt; &lt;/dependency&gt; application.yml 配置：singleServerConfig: timeout: 1000000 password: redis address: &quot;redis://127.0.0.1:6379&quot; 示例代码： RedissonClient 实例创建： @Value(&quot;$&#123;singleServerConfig.timeout&#125;&quot;) private int timeout; @Value(&quot;$&#123;singleServerConfig.password&#125;&quot;) private String password; @Value(&quot;$&#123;singleServerConfig.address&#125;&quot;) private String address; private RedissonClient redisson = null; @PostConstruct private void init() &#123; Config config = new Config(); config.useSingleServer() .setTimeout(timeout) .setPassword(password) .setAddress(address); redisson = Redisson.create(config); &#125; 简单使用： @Override @Transactional public TableRecord getTableInfo(String sjbspch, String tableName, String ext) &#123; RLock lock = redisson.getLock(&quot;REDIS_LOCK&quot;); lock.lock(); TableRecord currentRecord = null; try &#123; //业务逻辑。。。。。。。。。 &#125; catch (Exception e) &#123; System.out.println(&quot;error...&quot;); &#125; finally &#123; lock.unlock(); &#125; return currentRecord; &#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://flrpg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://flrpg.github.io/tags/redis/"}]},{"title":"线程池创建-中止","slug":"issue/issue-001","date":"2020-12-22T10:08:42.000Z","updated":"2021-03-16T02:31:32.883Z","comments":true,"path":"2020/12/22/issue/issue-001/","link":"","permalink":"https://flrpg.github.io/2020/12/22/issue/issue-001/","excerpt":"","text":"依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;/dependency&gt; 示例 private static void test5ThreadDown() &#123; int polGroupCount = 29999; int polPersonCount = 51000; int gSize = 8, pSize = 2; int gCount = polGroupCount / gSize, pCount = polPersonCount / pSize; //创建线程池 ExecutorService service = ThreadUtil.newExecutor(gSize + pSize); for (int i = 0; i &lt; gSize; i++) &#123; int startIndex = i * gCount; int endIndex = i * gCount + gCount; if (i == gSize - 1) &#123; endIndex = polGroupCount; &#125; if (startIndex == endIndex) &#123; continue; &#125; int finalEndIndex = endIndex; service.submit(() -&gt; &#123; try &#123; System.out.println(&quot;startIndex: &quot; + startIndex + &quot; endIndex: &quot; + finalEndIndex); for (int j = 0; j &lt; 5; j++) &#123; ThreadUtil.safeSleep(1000); System.out.println(Thread.currentThread().getName() + &quot;--j--&quot; + j); &#125; System.out.println(Thread.currentThread().getName() + &quot;-end......&quot;); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;); &#125; //线程池 service.shutdown(); while (true) &#123; if (service.isTerminated()) &#123; //当所有任务执行结束完成后，return true System.out.println(&quot;线程都结束勒。。。&quot;); break; &#125; ThreadUtil.safeSleep(1000); &#125; System.out.println(&quot;endAll==================&quot;); &#125;","categories":[{"name":"问题集","slug":"问题集","permalink":"https://flrpg.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"}],"tags":[{"name":"issue","slug":"issue","permalink":"https://flrpg.github.io/tags/issue/"}]},{"title":"jvm-class-loading","slug":"jvm/jvm01","date":"2020-12-22T09:01:31.000Z","updated":"2021-03-16T02:30:08.569Z","comments":true,"path":"2020/12/22/jvm/jvm01/","link":"","permalink":"https://flrpg.github.io/2020/12/22/jvm/jvm01/","excerpt":"","text":"类加载-初始化： Loading 双亲委派 LazyLoading ClassLoader源码 自定义类加载器 混合执行 编译执行 解释执行 Linking Verifivation（校验文件是否符合JVM规定） Perparation（！！！class 静态变量赋默认值） Resolution（常量池的各种符号引用解析为指针、偏移量等内存地址的直接引用） Initializing（调用类初始化代码，静态变量赋初值） 类加载器（父加载器不是继承关系） JVM按需动态加载采用双亲委派机制 类加载器 – 自顶向下进行实际查找和加载child方向 Bootstrap 加载lib、rt.jar chartset.jar 核心类，C++实现 Extension 加载扩展jar包 jre/lib/ext/*.jar，或由-Djava.ext.dirs指定 App 加载classpath指定内容 自底向上检查该类是否已经加载parent方向 CustomClassLoader 自定义的ClassLoader 双亲委派机制（安全） 父加载器 父加载器不是类“类加载器的加载器”。也不是“类加载器的父类加载器” 类加载器的范围 Launcher源码 双亲委派打破的问题 如何打破？重写ClassLoader中 loadClass 方法 何时打破？ JDK1.2之前自定义CLassLoader都必须重写loadClass 当前线程内指定ClassLoader，thread.setContextClassLoader 热启动，热部署 osgi、tomcat，可以加载不同版本的代码。 ClassLoader源码 loadClass（）方法 private final ClassLoader parent; //源码内不可修改 自定义类加载器 继承ClassLoader 重写模板方法findClass（） 调用defineClass 自定义类加载器加载自加密的class 防止反编译 防止篡改 混合模式 解释器 - bytecode intepreter JIT - Just In-Time compiler 混合模式 -Xmixed 默认混合模式。开始解释执行，启动较快，对热点代码实行检测和编译 -Xint 纯解释模式。启动快，执行慢 -Xcomp 纯编译模式，执行快，启动慢 检测热点代码：-XX:CompileThreshold = 10000 懒加载LazyLoading JVM规范没有规定何时加载 严格规定何时需要初始化 加载场景 new getstatic putstatic invokestatic指令，访问final 变量除外 java.lang.reflect 对类进行反射调用 初始化类的子类时，父类先加载 虚拟机启动时，被执行的主类必须初始化 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF getStatic Ref putstatic REF invokestatic 的方法句柄时，该类必须初始化","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"JVM","slug":"开发知识/JVM","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://flrpg.github.io/tags/jvm/"}]},{"title":"Init Hexo","slug":"hello-world","date":"2020-12-21T02:17:30.771Z","updated":"2021-03-12T02:32:01.205Z","comments":true,"path":"2020/12/21/hello-world/","link":"","permalink":"https://flrpg.github.io/2020/12/21/hello-world/","excerpt":"","text":"Hexo（记录自己搭建的流程）快速开始npm install hexo-cli -g hexo init npm install hexo server 插件git上传插件 npm install hexo-deployer-git --save hexo基本操作hexo clean &amp;&amp; hexo g &amp;&amp; hexo s hexo new &quot;My New Post&quot; hexo new post &quot;file&quot; 更换主题（3-hexo）修改主题配置上传到GithubPages内本机生成sshssh-keygen -t rsa -C &quot;email@github.com&quot; #github注册的邮箱 将本机路径下C:\\Users\\本机路径名.ssh\\id_rsa.pub 文件的内容放入Github -&gt;Setting -&gt; SSH and GPG keys内。 hexo d 发布项目，xxxxx.github.io 访问 本地目录索引- 读书 - 开发知识 - IO - JUC - JVM - 设计模式 - 数据结构 - 虚拟机 - 大前端 - 后端 - 数据库 - 运维 - 问题集 - 总结","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://flrpg.github.io/tags/hexo/"}]},{"title":"设计模式-责任链模式","slug":"dp/dp05cor","date":"2020-11-24T08:44:43.000Z","updated":"2020-11-25T02:14:48.895Z","comments":true,"path":"2020/11/24/dp/dp05cor/","link":"","permalink":"https://flrpg.github.io/2020/11/24/dp/dp05cor/","excerpt":"","text":"责任链说明： 每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 特点： 解耦合 增强责任链指派的灵活性（允许动态增加删除） 示例说明：（Filter-封装过滤-FilterChain）","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"}]},{"title":"设计模式Facade-Mediator","slug":"dp/dp04Facade-Mediator","date":"2020-11-24T05:46:40.000Z","updated":"2021-03-26T06:24:25.271Z","comments":true,"path":"2020/11/24/dp/dp04Facade-Mediator/","link":"","permalink":"https://flrpg.github.io/2020/11/24/dp/dp04Facade-Mediator/","excerpt":"","text":"","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"}]},{"title":"设计模式-工厂模式(抽象工厂)","slug":"dp/dp03factory","date":"2020-10-11T12:02:01.000Z","updated":"2021-03-26T09:53:39.103Z","comments":true,"path":"2020/10/11/dp/dp03factory/","link":"","permalink":"https://flrpg.github.io/2020/10/11/dp/dp03factory/","excerpt":"","text":"1、工厂模式说明： 定义对象创建的接口，让具体的子类将自身的创建过程延迟执行。 子类实现工厂接口，返回抽象对象，创建过程在子类实现。 特点： 对象创建者只需要知道对象名称，不要关注具体的实现过程。 扩展时只需要添加对应的工厂类就行。（但每增加对应产品都需要同时增加具体类与对象工厂） 2、抽象工厂说明： 相当与工厂的工厂，提供一个创建多个互相依赖对象（产品一族）的接口 特点： 在一个工厂内聚合多个产品。 方便扩展一个产品一族，但单个产品的扩展变麻烦了。","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"},{"name":"创建型","slug":"创建型","permalink":"https://flrpg.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"}]},{"title":"设计模式-策略模式","slug":"dp/dp02strategy","date":"2020-10-11T11:59:21.000Z","updated":"2021-03-24T03:15:29.176Z","comments":true,"path":"2020/10/11/dp/dp02strategy/","link":"","permalink":"https://flrpg.github.io/2020/10/11/dp/dp02strategy/","excerpt":"","text":"策略模式说明： 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 策略模式特点： 算法(策略)之间可以自由的切换，互相之间不会有影响 可扩展性好 策略的增加会导致实现类的递增 策略模式实例（sort）： 定义实体类Cat，Dog 省略构造方法。 public class Cat&#123; int height; int weight; String name; &#125; public class Dog&#123; int food; &#125; 实际需求： 比较两只Cat的height 比较两只Cat的weight 比较两只Dog的food /** * 定义具体的比较方法 */ public class Sort&lt;T&gt; &#123; public static void sort(Cat[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; index = arr[j].getHeight() &lt; arr[index].height ? j : index; &#125; swap(arr, index, i); &#125; &#125; private static void swap(Cat[] arr, int index, int i) &#123; Cat temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; public static void sort(Dog[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; index = arr[j].food &lt; arr[index].food ? j : index; &#125; swap(arr, index, i); &#125; &#125; private static void swap(Dog[] arr, int index, int i) &#123; Dog temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; &#125; /** * 定义测试类 */ public class Main &#123; public static void main(String[] args) &#123; //Cat height test01(); //Dog food test02(); &#125; private static void test01() &#123; Cat[] arr = &#123;new Cat( 1), new Cat( 5), new Cat( 3)&#125;; Sort.sort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void test02() &#123; Dog[] arr = &#123;new Dog( 1), new Dog( 5), new Dog( 3)&#125;; Sort.sort(arr); System.out.println(Arrays.toString(arr)); &#125; &#125; 问题：每定义多一种类比较的方法都要在Sort方法内添加具体的实现 定义Comparable比较方法 /** * 比较方法 * @param &lt;T&gt; */ public interface Comparable&lt;T&gt; &#123; int compareTo(T o); &#125; //实体类实现比较接口，Sort类定义新比较方法 &#123; public static void sort(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; index = arr[j].compareTo(arr[index]) == -1 ? j : index; &#125; swap(arr, index, i); &#125; &#125; private static void swap(Comparable[] arr, int index, int i) &#123; Comparable temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; &#125;","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"},{"name":"行为型","slug":"行为型","permalink":"https://flrpg.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"}]},{"title":"设计模式-单例设计模式","slug":"dp/dp01singleton","date":"2020-10-11T11:52:35.000Z","updated":"2021-03-26T06:31:35.333Z","comments":true,"path":"2020/10/11/dp/dp01singleton/","link":"","permalink":"https://flrpg.github.io/2020/10/11/dp/dp01singleton/","excerpt":"","text":"单例说明： 单例模式类只能有一个实例 单例模式类必须自己创建自己的唯一实例 单例模式类必须给所有其他对象提供这一实例 单例模式的特点： 静态化实例 私有化构造函数 提供公共的获取方法 单例的7种写法： 饿汉式 /** * @author LMZ * 饿汉式加载 * 优点：类加载到内存后，就实例化一个单例，JVM保证线程安全，推荐使用 */ public class Pl1 &#123; private static final Pl1 INSTANCE = new Pl1(); private Pl1() &#123;&#125; public static Pl1 getInstance() &#123; return INSTANCE; &#125; public void t()&#123; System.out.println(&quot;pl1&quot;); &#125; public static void main(String[] args) &#123; System.out.println(Pl1.getInstance().hashCode()); System.out.println(Pl1.getInstance().hashCode()); &#125; &#125; 懒汉式 /** * @author LMZ * 懒汉式 * 线程不安全，多线程访问时出现返回实例不唯一 */ public class Pl2 &#123; private static Pl2 INSTANCE; private Pl2() &#123;&#125; public static Pl2 getInstance()&#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Pl2(); &#125; return INSTANCE; &#125; public void t()&#123; System.out.println(&quot;pl2&quot;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Pl2.getInstance().hashCode()); &#125;).start(); &#125; &#125; &#125; 懒汉式，加锁 /** * @author LMZ * 懒汉式 * 在getInstance方法上，加Synchronized锁保证线程安全，效率低 */ public class Pl3 &#123; private static Pl3 INSTANCE; private Pl3() &#123;&#125; public synchronized static Pl3 getInstance()&#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Pl3(); &#125; return INSTANCE; &#125; public void t()&#123; System.out.println(&quot;pl3&quot;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Pl3.getInstance().hashCode()); &#125;).start(); &#125; &#125; &#125; 线程不安全 /** * @author LMZ * 线程不安全； * 在INSTANCE判断后，多线程在获取锁可能出现锁等待 */ public class Pl4 &#123; private static Pl4 INSTANCE; private Pl4() &#123; &#125; public static Pl4 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Pl4.class) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Pl4(); &#125; &#125; return INSTANCE; &#125; public void t() &#123; System.out.println(&quot;pl4&quot;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Pl4.getInstance().hashCode()); &#125;).start(); &#125; &#125; &#125; 双重锁 volatile 要加的原因可能出现在 INSTANCE = new Pl5()，由于指令重排序，可能当第一个线程在分配对象、（执行初始化，–未执行）、直接将对象引用赋给变量，第二线程可能拿到未初始化的不为null的INSTANCE 实例。 /** * @author LMZ * 双重锁检查 */ public class Pl5 &#123; private static volatile Pl5 INSTANCE; private Pl5() &#123; &#125; public static Pl5 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Pl5.class) &#123; if (INSTANCE == null) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; INSTANCE = new Pl5(); &#125; &#125; &#125; return INSTANCE; &#125; public void t() &#123; System.out.println(&quot;pl5&quot;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Pl5.getInstance().hashCode()); &#125;).start(); &#125; &#125; &#125; 静态内部类 /** * @author LMZ * 静态内部类实现单例 */ public class Pl6 &#123; private Pl6()&#123;&#125; private static class Pl6Helper&#123; private static Pl6 INSTANCE = new Pl6(); &#125; private static Pl6 getInstance() &#123; return Pl6Helper.INSTANCE; &#125; public void t() &#123; System.out.println(&quot;pl6&quot;); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Pl6.getInstance().hashCode()); &#125;).start(); &#125; &#125; &#125; 枚举实现单例 /** * @author LMZ * 枚举类实现单例 * 解决线程同步与反序列化 */ public enum Pl7 &#123; INSTANCE; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Pl7.INSTANCE.hashCode()); &#125;).start(); &#125; &#125; &#125;","categories":[{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"},{"name":"创建型","slug":"创建型","permalink":"https://flrpg.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"}]}],"categories":[{"name":"问题集","slug":"问题集","permalink":"https://flrpg.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"},{"name":"总结","slug":"总结","permalink":"https://flrpg.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"开发知识","slug":"开发知识","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"数据库","permalink":"https://flrpg.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JVM","slug":"开发知识/JVM","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/JVM/"},{"name":"设计模式","slug":"开发知识/设计模式","permalink":"https://flrpg.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"issue","slug":"issue","permalink":"https://flrpg.github.io/tags/issue/"},{"name":"tag1","slug":"tag1","permalink":"https://flrpg.github.io/tags/tag1/"},{"name":"os","slug":"os","permalink":"https://flrpg.github.io/tags/os/"},{"name":"Jpa","slug":"Jpa","permalink":"https://flrpg.github.io/tags/Jpa/"},{"name":"plan","slug":"plan","permalink":"https://flrpg.github.io/tags/plan/"},{"name":"redis","slug":"redis","permalink":"https://flrpg.github.io/tags/redis/"},{"name":"jvm","slug":"jvm","permalink":"https://flrpg.github.io/tags/jvm/"},{"name":"hexo","slug":"hexo","permalink":"https://flrpg.github.io/tags/hexo/"},{"name":"dp","slug":"dp","permalink":"https://flrpg.github.io/tags/dp/"},{"name":"创建型","slug":"创建型","permalink":"https://flrpg.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"},{"name":"行为型","slug":"行为型","permalink":"https://flrpg.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"}]}